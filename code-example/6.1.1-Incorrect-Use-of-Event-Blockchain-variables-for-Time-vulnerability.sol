// 漏洞程式碼示例：
// 下面的程式碼存在漏洞，因為合約在部署時把 block.timestamp 的值存入 state 變數 time，
// 此後在 pay() 函式中使用該固定值進行判斷，這使得該條件變得可以被預測和操縱。

contract Test {
    // 漏洞：在合約部署時記錄 block.timestamp，該值不會隨後更新
    uint time = block.timestamp;  // <== 漏洞重點：使用合約創建時的區塊時間作為判斷依據

    // pay() 函式依賴預先設定的時間，若 time % 2 為奇數則發送資金
    function pay() public {
        // 漏洞：應該依賴當前區塊資訊，而非部署時的時間，
        // 這樣會使得合約行為固定且容易被操縱
        if (time % 2 == 1) {  // <== 漏洞重點：錯誤使用事前記錄的區塊時間進行判斷
            // 使用 send 可能失敗，但這裡只是示範漏洞
            msg.sender.send(100);
        }
    }
}

// 補充說明：
// 由於 block.timestamp 可被礦工在小範圍內調整，
// 如果攻擊者能夠控制部署或操作該合約，則可利用此漏洞使 pay() 條件成立。