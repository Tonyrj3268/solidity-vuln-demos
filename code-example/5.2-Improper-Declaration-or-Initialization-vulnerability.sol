// 以下為存在 Improper Declaration or Initialization 漏洞的示範程式碼
// 此合約中有一個初始化函數 initialize()，該函數用以設定 owner，但並未限制呼叫者
// 因此，只要合約部署後未由信任的一方及時調用 initialize()，任何人都可呼叫 initialize() 取得 owner 權限

contract VulnerableContract {
    // 漏洞變數：owner 未於部署時正確初始化，導致其預設值為 address(0)
    // 攻擊者可利用 initialize() 修改此變數
    address public owner;  // BUG: 未在部署時賦值

    // 狀態變數 initialized 用於確認是否已初始化
    // 本來應該在部署時即正確初始化，但因設計不當，initialize() 為 public，任何人均可呼叫
    bool public initialized;

    // 漏洞函式：initialize() 未限制權限，導致任何人皆可呼叫
    function initialize() public {
        require(!initialized, "Already initialized");
        owner = msg.sender;  // BUG: 未鎖定只能有合法的初始化者
        initialized = true;
    }

    // withdraw() 僅允許 owner 執行，但若 initialize() 被惡意呼叫，owner 即被攻擊者控制
    function withdraw() public {
        require(msg.sender == owner, "Not owner");
        payable(owner).transfer(address(this).balance);
    }

    // 接受轉帳
    receive() external payable {}
}

/*
繁體中文補充說明：
在此漏洞中，initialize() 函式被不當設計為 public，
導致任何人都可以調用該函式來初始化合約，並設定 owner 為調用者，
從而使合法部署者失去對合約的控制權。本例中，資金提取函式 withdraw() 僅檢查 msg.sender 是否與 owner 相符，
但由於 owner 可被任意設定，攻擊者便可以利用此漏洞盜取合約資金。
*/
