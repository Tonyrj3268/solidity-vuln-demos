// 以下程式碼展示漏洞重點部位，已以中文註解標示出漏洞所在

contract Relayer {
    uint transactionId; // 追蹤交易 ID
    struct Tx {
        bytes data;
        bool executed;
    }
    mapping (uint => Tx) transactions;
    
    // vulnerability: relay 函式未檢查執行時的 gas 是否足夠，
    // 導致在呼叫 Target.execute() 時可能因 gas 不足而觸發 out-of-gas 異常，
    // 但交易狀態已被更新成 executed = true，造成邏輯非預期的行為。
    function relay(Target target, bytes memory _data) public returns(bool) {
        // 重放保護：不允許相同交易重複執行
        require(transactions[transactionId].executed == false, "same transaction twice");
        transactions[transactionId].data = _data;
        transactions[transactionId].executed = true;
        transactionId += 1;
        
        // vulnerability: 使用 .call 呼叫 execute()，但未指定 gas 限制，無法預先確認足夠 gas
        (bool success, ) = address(target).call(abi.encodeWithSignature("execute(bytes)", _data));
        return success;
    }
}

// 被 Relayer 呼叫的 Target 合約
contract Target {
    function execute(bytes memory _data) public {
        // Execute 合約程式碼（此處未檢查 gas 剩餘量，容易被攻擊）
    }
}
