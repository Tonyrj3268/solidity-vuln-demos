/*
漏洞名稱：Transfer Pre-Condition Dependent on Transaction Order
描述：在此漏洞中，交易的執行順序會影響交易前置條件的檢查，可能導致部分交易失敗或以預期外的狀態執行。
注意：已更新為 Solidity 0.8.0 語法，利用 constructor 關鍵字取代與合約同名的構造函式。
*/

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

contract TransactionOrdering {
    // 漏洞重點：price 變數未與交易順序鎖定
    uint256 public price;
    address public owner;

    event Purchase(address indexed _buyer, uint256 _price);
    event PriceChange(address indexed _owner, uint256 _price);

    modifier ownerOnly() {
        require(msg.sender == owner, "Caller is not owner");
        _;
    }

    // 使用 constructor 關鍵字定義構造函式
    constructor() {
        owner = msg.sender;
        price = 100;
    }

    // 漏洞所在：buy() 函式執行時未鎖定交易順序，不管 state 是否已被改變
    function buy() public returns (uint256) {
        // 這裡沒有任何前置檢查機制以確保 state 未被後續交易改變
        emit Purchase(msg.sender, price);
        return price;
    }

    // setPrice 為 owner 專用，更新 price 可能會導致已在區塊鏈排隊的 buy() 交易以舊的前置條件執行
    function setPrice(uint256 _price) public ownerOnly {
        price = _price;
        emit PriceChange(owner, price);
    }
}

/*
攻擊範例說明：
1. 攻擊者部署 AttackOrdering 合約，並連結目標 TransactionOrdering 合約地址。
2. 攻擊者呼叫 executeAttack() 模擬買入操作。
3. 若在交易被打包前，owner 呼叫 setPrice() 改變價格，則原本排隊的 buy() 交易取得的 price 就不是預期的值。
*/

contract AttackOrdering {
    TransactionOrdering public vulnerable;
    address public attacker;

    event AttackResult(uint256 returnedPrice);

    // 使用 constructor 初始化連結 vulnerability 合約
    constructor(address _vulnerableAddress) {
        vulnerable = TransactionOrdering(_vulnerableAddress);
        attacker = msg.sender;
    }

    // executeAttack 模擬發送 buy() 交易，展示交易順序問題
    function executeAttack() public {
        // 在下列交易中，假設在交易被打包前 owner 呼叫 setPrice() 更新了 price
        uint256 priceBefore = vulnerable.price();
        uint256 boughtPrice = vulnerable.buy();
        emit AttackResult(boughtPrice);
    }
}
