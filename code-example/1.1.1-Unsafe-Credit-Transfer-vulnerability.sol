// 漏洞程式碼範例：Unsafe Credit Transfer（不安全的 Credit Transfer）
// 這個漏洞使得攻擊者能透過重入攻擊，在受害合約尚未更新餘額前就持續呼叫提領，從而提取超過他應得的資金

contract WalletVulnerable {
    mapping(address => uint) private userBalances;  // 狀態變數：記錄每個地址的餘額

    // 用戶可將 ETH 存入合約
    function deposit() public payable {
        userBalances[msg.sender] += msg.value;
    }

    // 漏洞函式：Withdraw 操作中存在重入風險
    function withdrawBalance() public {
        uint amountToWithdraw = userBalances[msg.sender];
        if (amountToWithdraw > 0) {
            // 問題：先執行 credit transfer，使用 call() 將資金傳給 msg.sender；
            // 此時如果 msg.sender 是一個攻擊合約，它可在 fallback() 中重入呼叫此函式
            (bool success, ) = msg.sender.call{value: amountToWithdraw}("");  // 【漏洞重點】轉帳前未更新用戶餘額
            require(success, "Transfer failed");
            // 狀態更新延遲到資金傳輸之後，使得攻擊者可利用同一筆餘額多次提領
            userBalances[msg.sender] = 0;
        }
    }

    // 其他相關函式...
    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
}
