// 存在重入攻擊漏洞的錢包合約
contract Wallet {
    // 用於儲存每個用戶的餘額
    mapping(address => uint) private userBalances;
    
    // 允許用戶存款
    function deposit() external payable {
        // 將發送的以太幣記錄到用戶餘額中
        userBalances[msg.sender] += msg.value;
    }
    
    // 提款函數 - 包含重入漏洞
    function withdrawBalance() public {
        // 獲取用戶餘額
        uint amountToWithdraw = userBalances[msg.sender];
        
        // 檢查用戶餘額是否大於0
        if (amountToWithdraw > 0) {
            // 漏洞點1: 在更新餘額之前發送以太幣
            // 這允許攻擊者在餘額更新前重復調用此函數
            // 正確的做法應該是先更新狀態，再進行外部調用（檢查-效果-互動模式）
            (bool success, ) = msg.sender.call{value: amountToWithdraw}("");
            
            // 漏洞點2: 即使轉賬失敗，餘額也會被置零
            // 應該檢查轉賬是否成功，只有在成功時才更新餘額
            userBalances[msg.sender] = 0;
        }
    }
    
    // 檢查用戶餘額
    function getBalance(address _user) external view returns (uint) {
        return userBalances[_user];
    }
    
    // 查看合約餘額
    function getContractBalance() external view returns (uint) {
        return address(this).balance;
    }
}

/*
重入攻擊漏洞分析：

1. 主要漏洞：在 withdrawBalance() 函數中，代碼執行了一個外部調用(msg.sender.call)向用戶發送以太幣，
   然後才更新了用戶的餘額為0。這違反了"檢查-效果-互動"(Checks-Effects-Interactions)模式。

2. 攻擊向量：當接收方是一個合約並實現了回退函數(receive/fallback)時，該合約可以在接收以太幣時
   再次調用 withdrawBalance()。由於用戶餘額尚未被更新，每次調用都會讀取到初始餘額，
   使攻擊者能夠多次提取相同金額的以太幣。

3. 嚴重程度：極高。攻擊者可以耗盡合約中的所有資金，即使他們初始只存入了少量資金。
*/