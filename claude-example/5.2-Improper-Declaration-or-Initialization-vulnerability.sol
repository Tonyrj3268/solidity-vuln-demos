// 有漏洞的智能合約 - 未正確初始化資源

contract VulnerableWallet {
    // 狀態變數
    address public owner; // 【漏洞】這個變數沒有被正確初始化
    bool public initialized; // 【漏洞】這個初始化標誌變數沒有被使用來保護 initialize 函式
    mapping(address => uint256) public balances;
    
    // 【漏洞】constructor 沒有初始化 owner，容易導致權限控制問題
    constructor() {
        // 這裡應該設置 owner = msg.sender，但沒有這樣做
    }
    
    // 【漏洞】initialize 函式沒有適當的訪問控制，任何人都可以呼叫並成為 owner
    function initialize(address _owner) public {
        // 【漏洞】缺少檢查確保該函式只能被呼叫一次
        owner = _owner;
        initialized = true;
    }
    
    // 存款函式
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }
    
    // 取款函式
    function withdraw(uint256 amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
    }
    
    // 【漏洞】提取所有資金的函式，但只有正確的訪問控制才能防止未授權提款
    function withdrawAll() public {
        require(msg.sender == owner, "Only owner can withdraw all");
        payable(msg.sender).transfer(address(this).balance);
    }
    
    // 接收資金的函式
    receive() external payable {
        balances[msg.sender] += msg.value;
    }
}

/*
漏洞說明：
1. 最主要的問題是 owner 變數沒有在構造函數中初始化，而是依賴後續的 initialize 函式設置
2. initialize 函式沒有任何訪問控制，任何用戶都可以呼叫它並將自己設為 owner
3. 雖然有 initialized 變數來標示是否已初始化，但實際上並未用於防止重複初始化
4. 由於 owner 可以呼叫 withdrawAll() 函式並提取合約中的所有資金，這使得攻擊者可以竊取所有用戶的資金
5. 這種初始化模式常見於代理合約或可升級合約，但實作不當會導致嚴重的安全風險
*/