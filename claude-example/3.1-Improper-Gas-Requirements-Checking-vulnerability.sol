// 有漏洞的 Relayer 合約
contract Relayer {
    uint transactionId;
    struct Tx {
        bytes data;
        bool executed;
    }
    mapping (uint => Tx) transactions;
    
    // 漏洞：沒有指定或檢查目標函式所需的 gas，可能導致執行失敗但狀態已更新
    function relay(Target target, bytes memory _data) public returns(bool) {
        // 重放保護：不要呼叫相同的交易兩次
        require(transactions[transactionId].executed == false, "same transaction twice");
        
        // 注意：這裡先更新狀態，但沒有檢查目標函式執行是否有足夠的 gas
        transactions[transactionId].data = _data;
        transactions[transactionId].executed = true;
        transactionId += 1;
        
        // 漏洞：沒有指定 gas 限制，如果目標函式需要大量 gas，可能會失敗
        // 但此時狀態已更新，導致不一致性
        (bool success, ) = address(target).call(abi.encodeWithSignature("execute(bytes)", _data));
        return success;
    }
}

// 被 Relayer 呼叫的合約
contract Target {
    // 漏洞：沒有檢查可用的 gas 是否足夠執行後續操作
    function execute(bytes memory _data) public {
        // 這裡可能執行需要大量 gas 的操作，但沒有先檢查可用 gas
        // 如果 gas 不足，函式執行會失敗，但 Relayer 已經更新了狀態
    }
}

/*
漏洞說明：

1. gas 需求未檢查：
   - Relayer 合約沒有指定或檢查目標函式執行所需的 gas 量
   - Target 合約沒有檢查是否有足夠的 gas 來完成操作

2. 狀態提前變更：
   - Relayer 在呼叫目標函式前就更新了交易狀態
   - 如果目標函式因 gas 不足而失敗，將導致狀態不一致

3. 潛在影響：
   - 交易可能被標記為已執行，但實際上執行失敗了
   - 攻擊者可以利用這一點，提交需要大量 gas 的交易，導致系統狀態混亂
   - 如果有依賴於交易執行狀態的其他邏輯，可能會造成更嚴重的問題
*/