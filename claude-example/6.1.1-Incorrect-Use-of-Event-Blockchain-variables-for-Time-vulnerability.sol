contract Test {
    // 漏洞點1: 將區塊時間戳存儲為狀態變數
    // 這樣做會固定時間戳，但實際上每次交易的區塊時間戳可能不同
    uint time = block.timestamp;
    
    function pay() public {
        // 漏洞點2: 使用區塊時間戳作為隨機性或條件決策的依據
        // 區塊時間戳可被礦工在一定範圍內操控（約30秒）
        if (time % 2 == 1) {
            // 如果時間戳是奇數，則發送100單位的以太幣給呼叫者
            msg.sender.send(100);
        }
    }
    
    // 這個合約缺少充值函數，無法接收以太幣，因此實際上無法支付
    // 為了演示完整性，應該要有接收以太幣的功能
}

/*
漏洞說明：
1. 合約在建構時將當前區塊時間戳存儲為狀態變數time，之後所有的pay()呼叫都使用這個固定的時間戳
2. 區塊時間戳（block.timestamp）不適合作為隨機數來源或條件判斷的唯一依據
3. 礦工可以在約30秒的範圍內操縱時間戳，決定是否處理交易
4. 若time為奇數，攻擊者可以重複呼叫pay()方法，每次都能獲得100單位以太幣
5. 若time為偶數，礦工可能會拒絕打包此合約的建構交易，直到時間戳變成奇數
*/