contract IntegerOverflowMappingSym1 {
    mapping(uint256 => uint256) map;
    
    // 漏洞函式: 這個函式允許直接使用 += 運算符增加映射值，但沒有檢查整數溢出
    function init(uint256 k, uint256 v) public {
        // 漏洞點: 使用 += 運算符沒有檢查溢出
        // 當 map[k] + v 大於 2^256-1 時，結果會溢出並「繞回」變成一個小值
        map[k] += v;  // 危險! 未檢查溢出風險
    }
}

/*
漏洞說明：
整數溢出發生在當一個數值運算的結果超過了該類型能夠表示的最大值範圍。在 Solidity 中，
uint256 類型的最大值是 2^256-1。當兩個數字相加的結果超過這個最大值時，結果會「繞回」
並從 0 開始重新計算。

在這個合約中，map[k] += v 操作沒有檢查 map[k] + v 是否會超過 uint256 的最大值。
如果發生溢出，變數值會變得不正確，可能導致嚴重的邏輯錯誤，特別是在處理金額或計數器時。

在 Solidity 0.8.0 版本之前，這類溢出不會自動檢查，開發者必須手動實現溢出檢查（如使用 SafeMath）。
Solidity 0.8.0 之後的版本雖然已內建溢出檢查，但考慮到兼容性和明確性，仍建議使用安全的數學庫。
*/