// 有漏洞的合約 - Integer Underflow 風險
contract IntegerOverflowMappingSym1 {
    // 用於儲存鍵值對的映射
    mapping(uint256 => uint256) map;
    
    // 有漏洞的函式：對映射中的值進行減法操作
    function init(uint256 k, uint256 v) public {
        // 漏洞點：這裡對 map[k] 直接進行減法操作，而沒有檢查減法是否會導致下溢
        // 在 Solidity 中，如果 map[k] < v，則會導致整數下溢，結果會是一個非常大的數字
        // 未初始化的 mapping 元素預設值為 0，任何正數 v 都會導致下溢
        map[k] -= v;
    }
    
    // 如果這是一個管理資產或權限的合約，下溢可能導致：
    // 1. 資產計算錯誤（例如突然擁有巨額代幣）
    // 2. 繞過權限或限制檢查
    // 3. 破壞合約的業務邏輯
}

/*
漏洞解釋：
- 整數下溢發生在對無符號整數執行的結果小於該類型允許的最小值（對 uint 來說是 0）時
- 在這個例子中，map[k] 可能為 0 或很小的值，當 v 大於 map[k] 時，減法操作會導致下溢
- Solidity 0.8.0 版本之前，不會自動檢查溢出/下溢情況
- 即使在 0.8.0 版本後會自動檢查，使用 unchecked 區塊仍可繞過檢查
- 此漏洞常被用於繞過餘額檢查或獲取大量資源
*/