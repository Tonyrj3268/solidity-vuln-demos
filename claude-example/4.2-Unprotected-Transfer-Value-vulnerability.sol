contract MultiOwnable {
  // 未初始化的狀態變數 owners，應該用來追踪誰是合約擁有者
  mapping(address => address) public owners;

  modifier onlyOwner() {
    require(owners[msg.sender] != 0, "Not an owner");
    _;
  }

  // 【漏洞1】缺少 onlyOwner 修飾符，任何人都可以添加新擁有者
  // 這導致任何人都可以註冊自己為擁有者，從而獲得合約的控制權
  function newOwner(address _owner) external returns (bool) {
    require(_owner != 0, "Invalid address");
    owners[_owner] = msg.sender;
    return true;
  }
}

contract TestContract is MultiOwnable {
  // 【漏洞2】使用 this.balance 無限制地轉移所有合約餘額
  // 這本身可能不是問題，但與 newOwner 函式的權限問題結合時非常危險
  function withdrawAll() onlyOwner {
    msg.sender.transfer(this.balance);
  }
  
  // 允許合約接收 ETH
  function() payable {
  }
}

/* 
主要漏洞解釋：
1. 缺乏初始擁有者設定：合約沒有在建構函式中設定初始擁有者
2. 未受保護的擁有者添加：newOwner 函式沒有 onlyOwner 修飾符，任何人都可以添加新擁有者
3. 無限制轉移：withdrawAll 函式無限制地轉移合約的全部餘額
4. 安全上下文問題：結合以上漏洞，攻擊者可以自行成為擁有者並提取所有資金
*/