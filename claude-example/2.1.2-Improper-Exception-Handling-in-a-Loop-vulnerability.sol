contract CallsInLoop {
    // 狀態變數：目的地地址陣列，存儲需要轉移資金的多個接收者地址
    address[] public destinations;
    
    constructor(address[] memory newDestinations) {
        destinations = newDestinations;
    }
    
    // 漏洞函數：在迴圈中直接執行外部呼叫
    function bad() external {
        // 【漏洞1】：在迴圈中執行 transfer 操作
        // 問題：如果 destinations 陣列非常大，執行可能會耗盡 gas 或超過區塊 gas 限制
        // 問題：如果其中任何一個 transfer 失敗，整個交易都會回滾，已消耗的 gas 不會返還
        for (uint i = 0; i < destinations.length; i++) {
            // 【漏洞2】：transfer 是一個外部呼叫，可能失敗
            // - 如果接收者是合約且沒有 fallback/receive 函數
            // - 如果接收者是合約且其 fallback/receive 函數執行失敗
            // - 如果 gas 不足以完成所有操作
            payable(destinations[i]).transfer(i);
        }
        // 【漏洞3】：沒有任何機制來處理部分失敗的情況
        // 一旦其中一個 transfer 失敗，所有之前成功的操作都會被回滾
    }
    
    // 合約沒有任何應對機制來：
    // 1. 限制迴圈的大小
    // 2. 分批處理轉賬
    // 3. 使用拉取模式（Pull Pattern）而非推送模式（Push Pattern）
}

/*
漏洞解釋：
1. 在迴圈中進行外部呼叫（如 transfer）是一種不良實踐，因為：
   - 每次外部呼叫都可能失敗，導致整個交易回滾
   - 大量的外部呼叫會消耗大量 gas，可能會超出區塊的 gas 限制
   - 如果交易失敗，已經消耗的 gas 不會返還給用戶

2. 推送模式問題：
   - 目前合約使用「推送模式」主動發送資金給多個接收者
   - 這使得合約的執行受到外部合約行為的影響
   - 如果任何一個接收者拒絕接收資金，整個交易就會失敗

3. 缺乏彈性：
   - 合約沒有提供機制來處理部分失敗的情況
   - 沒有批次處理或分隔交易的方法來減少 gas 消耗和失敗風險
*/